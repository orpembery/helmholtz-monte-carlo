import firedrake as fd
import helmholtz_monte_carlo.point_generation as point_gen
import helmholtz_monte_carlo.generate_samples as gen_samples
import helmholtz_firedrake.problems as hh
import numpy as np
import latticeseq_b2
from helmholtz_firedrake import coefficients as coeff
from helmholtz_firedrake import utils
import pytest

def test_mc_points_correct():
    """Tests that Monte Carlo points are in the (centred) unit cube.

    Also provides a quick 'check' that the points are random.
    """
    
    J = 100
    N = 1024
    point_generation_method = 'mc'
    seed = 42
    section = [0,1]
    points = point_gen.mc_points(J,N,point_generation_method,section,seed)
    assert (-0.5 <= points).all() and (points <= 0.5).all()

    # The following is a 'quick and dirty' check that the points are
    # random - whether their average is near the centre of the cube. The
    # threshold for 'near' is a heuristic that I chose by looking at
    # generated random numbers.
    assert np.isclose(points.mean(),0.0,atol=0.0025)

    
def test_qmc_points_correct():
    """Tests that Monte Carlo points are in the (centred) unit cube.

    Also checks that they are the same as generated by Dirk Nuyens' code
    (although given Dirks code underlies the code being tested, this
    isn't a great test). But the test was written without looking at the
    code being tested, so maybe that makes it slightly better.

    """
    J = 100
    N = 1024
    point_generation_method = 'qmc'
    points = point_gen.mc_points(J,N,point_generation_method,[0,1])
    assert (-0.5 <= points).all() and (points <= 0.5).all()

    true_points_gen = latticeseq_b2.latticeseq_b2(s=J)

    for m in range(11):
        true_points = true_points_gen.calc_block(m) - 0.5
        if m == 0:
            # Dealing with  indexing
            assert (true_points == points[0:1,:]).all()
        else:
            assert (true_points == points[2**(m-1):2**m,:]).all()

        
def test_points_shift():
    """Tests that shifted points are inside the unit square.

    Also tests that all points are shifted the same, and that the shift
    is random.

    """
    J = 100
    N = 1024
    point_generation_method = 'mc'
    seed = 42
    points = point_gen.mc_points(J,N,point_generation_method,[0,1],seed)

    shifted_points = point_gen.shift(points)

    assert (-0.5 <= shifted_points).all() and (shifted_points <= 0.5).all()

    # Checking points have been shifted by the same amount. If either
    # point has, in any coordinate, been 'wrapped round', then the
    # difference in their shifts will be 1 (the size of the hypercube).
    shift_0 = shifted_points[0,:] - points[0,:]

    shift_1 = shifted_points[1,:] - points[1,:]

    # This is a bit of a hack, because arrays of truth values are
    # complicated. It says that for every element of the arrays, either
    # they are equal, or they differ by 1.
    differences = (shift_0 - shift_1) * (np.abs(shift_0-shift_1) - 1)

    assert np.allclose(differences,0)
    
    # Heuristic check (similar to that in test_mc_points_correct) that
    # the shift is random.
    assert shift_0.mean() < 0.07

def test_all_qoi_samples():
    """Test that the code correctly samples all of the stochastic points."""
    mesh = fd.UnitSquareMesh(10,10,comm=fd.COMM_WORLD)

    J = 100

    delta = 2.0

    lambda_mult = 1.0

    j_scaling = 1.0

    n_0 = 1.0

    num_points = 20

    stochastic_points = np.zeros((num_points,J))
    
    n_stoch = coeff.UniformKLLikeCoeff(mesh,J,delta,lambda_mult,j_scaling,n_0,stochastic_points)

    k = 1.0
    
    V = fd.FunctionSpace(mesh,"CG",1)

    prob = hh.StochasticHelmholtzProblem(k,V,A_stoch=None,n_stoch=n_stoch)

    angle = 2.0*np.pi/3.0
    
    prob.f_g_plane_wave([np.cos(angle),np.sin(angle)])

    prob.use_mumps()

    samples = gen_samples.all_qoi_samples(prob,['testing'],fd.COMM_WORLD,False)
    assert len(samples) == 1
    assert np.allclose(samples[0],np.arange(1.0,float(num_points)+1.0))

@pytest.mark.xfail
def test_mc_sample_generation():
    k = 1.0

    h_spec = (1.0,-1.5)

    J = 100

    nu = 16

    M = 4

    point_generation_method = 'mc'

    delta = 2.0

    lambda_mult = 1.0

    j_scaling = 1.0

    num_spatial_cores = 1

    qois = ['testing']

    output = gen_samples.generate_samples(k,h_spec,J,nu,M,
                                          point_generation_method,
                                          delta,lambda_mult,j_scaling,qois,num_spatial_cores,dim=2)

    N = float(nu*2**M)
    
    assert np.isclose(output[1],(N+1.0)/2.0)
    
    assert np.isclose(output[2],np.sqrt((N+1.0)/12.0))
    

def test_qmc_sample_generation():
    """Tests that all the anscillary code (apart from actually calculating
the qois) for qmc points happens in an expected way."""
    k = 1.0

    h_spec = (1.0,-1.5)

    J = 100

    nu = 16

    M = 4

    point_generation_method = 'qmc'

    delta = 2.0

    lambda_mult = 1.0

    j_scaling = 1.0

    qois = ['testing']

    num_spatial_cores = 1

    output = gen_samples.generate_samples(k,h_spec,J,nu,M,
                                          point_generation_method,
                                          delta,lambda_mult,j_scaling,qois,
                                          num_spatial_cores,dim=2)

    for shift_no in range(nu):
        assert np.allclose(output[1][shift_no][0],[float(ii) for ii in range(1,2**M + 1)])


def test_multiple_qois_qmc():
    """Checks that anscillary code with multiple qois works for QMC."""

    k = 1.0

    h_spec = (1.0,-1.5)

    J = 100

    #    nu = 16
    nu=2

    M = 4

    point_generation_method = 'qmc'

    delta = 2.0

    lambda_mult = 1.0

    j_scaling = 1.0
    
    num_spatial_cores = 1
    
    # This is just testing that we correctly handle multiple qois
    qois = ['testing','testing']
    

    output = gen_samples.generate_samples(k,h_spec,J,nu,M,
                                          point_generation_method,
                                          delta,lambda_mult,j_scaling,qois,
                                          num_spatial_cores,dim=2)

    # First qoi
    for shift_no in range(nu):
        assert np.allclose(output[1][shift_no][0],[float(ii) for ii in range(1,2**M + 1)])

    # Second qoi
    for shift_no in range(nu):
        assert np.allclose(output[1][shift_no][1],[float(ii) for ii in range(1,2**M + 1)])


@pytest.mark.xfail
def test_multiple_qois_mc():
    """Checks that multiple qois are calculated correctly for MC."""

    k = 1.0

    h_spec = (1.0,-1.5)

    J = 100

    nu = 16

    M = 4

    point_generation_method = 'mc'

    delta = 2.0

    lambda_mult = 1.0

    j_scaling = 1.0

    # This is just testing that we correctly handle multiple qois
    qois = ['testing','testing']
    

    output = gen_samples.generate_samples(k,h_spec,J,nu,M,
                                          point_generation_method,
                                          delta,lambda_mult,j_scaling,qois,dim=2)

    N = nu*(2**M)
    
    # First qoi
    assert np.isclose(output[1][0],(float(N)+1.0)/2.0)
    
    assert np.isclose(output[2][0],np.sqrt((float(N)+1.0)/12.0))
    
    # Second qoi
    assert np.isclose(output[1][1],(float(N)+1.0)/2.0)
    
    assert np.isclose(output[2][1],np.sqrt((float(N)+1.0)/12.0))

    

    
def test_set_seed():
    """Checks the numpy seed setter works."""

    np.random.seed(1)

    random_number_1 = np.random.rand(1)

    point_gen.set_numpy_seed(None)

    random_number_2 = np.random.rand(1)

    assert random_number_1 != random_number_2

    point_gen.set_numpy_seed(1)

    random_number_3 = np.random.rand(1)

    assert random_number_1 == random_number_3

def test_qoi_finder():
    """Checks the qoi helper function."""

    qois = ['integral','origin','integral']

    this_qoi = 'integral'

    output = gen_samples.qoi_finder(qois,this_qoi)

    assert output[0]

    assert output[1] == [0,2]

    this_qoi = 'origin'

    output = gen_samples.qoi_finder(qois,this_qoi)

    assert output[0]

    assert output[1] == [1]

    this_qoi = 'foo'

    output = gen_samples.qoi_finder(qois,this_qoi)
    
    assert not output[0]

    assert output[1] == []
