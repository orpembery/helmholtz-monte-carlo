import firedrake as fd
import helmholtz_monte_carlo.point_generation as point_gen
import helmholtz_monte_carlo.error_analysis as err_an
import helmholtz_firedrake.problems as hh
import numpy as np
import latticeseq_b2
from helmholtz_firedrake import coefficients as coeff
from helmholtz_firedrake import utils

def test_mc_points_correct():
    """Tests that Monte Carlo points are in the (centred) unit cube.

    Also provides a quick 'check' that the points are random.
    """
    
    J = 100
    N = 1024
    point_generation_method = 'mc'
    seed = 42
    points = point_gen.mc_points(J,N,point_generation_method,seed)
    assert (-0.5 <= points).all() and (points <= 0.5).all()

    # The following is a 'quick and dirty' check that the points are
    # random - whether their average is near the centre of the cube. The
    # threshold for 'near' is a heuristic that I chose by looking at
    # generated random numbers.
    assert np.abs(points.mean()) < 0.0025

    
def test_qmc_points_correct():
    """Tests that Monte Carlo points are in the (centred) unit cube.

    Also checks that they are the same as generated by Dirk Nuyens' code
    (although given Dirks code underlies the code being tested, this
    isn't a great test). But the test was written without looking at the
    code being tested, so maybe that makes it slightly better.

    """
    J = 100
    N = 1024
    point_generation_method = 'qmc'
    points = point_gen.mc_points(J,N,point_generation_method)
    assert (-0.5 <= points).all() and (points <= 0.5).all()

    true_points_gen = latticeseq_b2.latticeseq_b2(s=J)

    for m in range(11):
        true_points = true_points_gen.calc_block(m) - 0.5
        if m == 0:
            # Dealing with  indexing
            assert (true_points == points[0:1,:]).all()
        else:
            assert (true_points == points[2**(m-1):2**m,:]).all()

        
def test_points_shift():
    """Tests that shifted points are inside the unit square.

    Also tests that all points are shifted the same, and that the shift
    is random.

    """
    J = 100
    N = 1024
    point_generation_method = 'mc'
    seed = 42
    points = point_gen.mc_points(J,N,point_generation_method,seed)

    shifted_points = point_gen.shift(points)

    assert (-0.5 <= shifted_points).all() and (shifted_points <= 0.5).all()

    # Checking points have been shifted by the same amount. If either
    # point has, in any coordinate, been 'wrapped round', then the
    # difference in their shifts will be 1 (the size of the hypercube).
    shift_0 = shifted_points[0,:] - points[0,:]

    shift_1 = shifted_points[1,:] - points[1,:]

    # This is a bit of a hack, because arrays of truth values are
    # complicated. It says that for every element of the arrays, either
    # they are equal, or they differ by 1.
    differences = (shift_0 - shift_1) * (np.abs(shift_0-shift_1) - 1)

    assert (differences == 0).all()
    
    # Heuristic check (similar to that in test_mc_points_correct) that
    # the shift is random.
    assert shift_0.mean() < 0.07

def test_all_qoi_samples():
    mesh = fd.UnitSquareMesh(10,10)

    J = 100

    delta = 2.0

    lambda_mult = 1.0

    n_0 = 1.0

    num_points = 20

    stochastic_points = np.zeros((num_points,J))
    
    n_stoch = coeff.UniformKLLikeCoeff(mesh,J,delta,lambda_mult,n_0,stochastic_points)

    k = 1.0
    
    V = fd.FunctionSpace(mesh,"CG",1)

    prob = hh.StochasticHelmholtzProblem(k,V,A_stoch=None,n_stoch=n_stoch)

    prob.f_g_plane_wave()

    prob.use_mumps()

    samples = err_an.all_qoi_samples(prob,'testing')

    assert np.allclose(samples,np.arange(1.0,float(num_points)+1.0))
    
def test_mc_calculation():
    k_range = [1.0]

    h_spec = (1.0,-1.5)

    J_range = [100]

    nu = 16

    M_range = [4]

    point_generation_method = 'mc'

    delta = 2.0

    lambda_mult = 1.0

    qoi = 'testing'

    output = err_an.investigate_error(k_range,h_spec,J_range,nu,M_range,
                                      point_generation_method,
                                      delta,lambda_mult,qoi,dim=2)

    N = float(nu*2**M_range[0])
    
    assert np.isclose(output[1],(N+1.0)/2.0)
    
    assert np.isclose(output[2],np.sqrt((N+1.0)/12.0))

def test_qmc_error_calculation():
    k_range = [1.0]

    h_spec = (1.0,-1.5)

    J_range = [100]

    nu = 16

    M_range = [4]

    point_generation_method = 'qmc'

    delta = 2.0

    lambda_mult = 1.0

    qoi = 'testing_qmc'

    output = err_an.investigate_error(k_range,h_spec,J_range,nu,M_range,
                                      point_generation_method,
                                      delta,lambda_mult,qoi,dim=2)
    
    assert np.isclose(output[1],(float(nu)+1.0)/2.0)
    
    assert np.isclose(output[2],np.sqrt((float(nu)+1.0)/12.0))

def test_qoi_integral():
    """Checks that the correct qoi is calculated for a plane wave.

    Qoi is the integral of the function over the domain.
    """

    dim = 2
    
    k = 20.0

    num_points = utils.h_to_num_cells(k**-1.5,dim)
    
    mesh = fd.UnitSquareMesh(num_points,num_points)

    J = 1

    delta = 2.0

    lambda_mult = 1.0

    n_0 = 1.0

    num_points = 1

    stochastic_points = np.zeros((num_points,J))
    
    n_stoch = coeff.UniformKLLikeCoeff(mesh,J,delta,lambda_mult,n_0,stochastic_points)
    
    V = fd.FunctionSpace(mesh,"CG",1)

    prob = hh.StochasticHelmholtzProblem(k,V,A_stoch=None,n_stoch=n_stoch)

    d_list = [np.cos(np.pi/4.0),np.sin(np.pi/4.0)]

    d = fd.as_vector(d_list)
    prob.f_g_plane_wave()

    prob.use_mumps()

    samples = err_an.all_qoi_samples(prob,'integral')

    # Should be just one sample
    assert samples.shape[0] == 1

    true_integral = (1j/k)**float(dim) *  1.0/np.array(d_list).prod()\
                    * (1.0-np.exp(1j*k*np.array(d_list))).prod()
    
    # This should be the integral over the unit square/cube of a plane
    # wave I've tweaked the definition of 'closeness' as there's
    # obviously some FEM error coming in here. But working on a finer
    # mesh, you see that the computed value approaches the true integral
    # (I've only run it for a plane wave incident from the bottom-left
    # corner), so I'm confident this is computing the correct value,
    # modulo FEM error.  The value of rtol has been chosen by looking at
    # the error for a plane wave incident from the bottom left (d =
    # [1/sqrt(2),1/sqrt(2)]), and choosing rtol so that test
    # passes. However, the actual test above is run with a different
    # incident plane wave.
    assert np.isclose(samples[0],true_integral,atol=1e-16,rtol=1e-2)

def test_qoi_origin():
    """Checks that the correct qoi is calculated for a plane wave.

    Qoi is the value of the function at the origin.
    """

    dim = 2
    
    k = 20.0

    num_points = utils.h_to_num_cells(k**-1.5,dim)
    
    mesh = fd.UnitSquareMesh(num_points,num_points)

    J = 1

    delta = 2.0

    lambda_mult = 1.0

    n_0 = 1.0

    num_points = 1

    stochastic_points = np.zeros((num_points,J))
    
    n_stoch = coeff.UniformKLLikeCoeff(mesh,J,delta,lambda_mult,n_0,stochastic_points)
    
    V = fd.FunctionSpace(mesh,"CG",1)

    prob = hh.StochasticHelmholtzProblem(k,V,A_stoch=None,n_stoch=n_stoch)

    d_list = [np.cos(np.pi/8.0),np.sin(np.pi/8.0)]

    d = fd.as_vector(d_list)
    prob.f_g_plane_wave()

    prob.use_mumps()

    samples = err_an.all_qoi_samples(prob,'origin')

    # Should be just one sample
    assert samples.shape[0] == 1

    true_value = 1.0
    
    print(true_value)

    print(samples[0])
    # Tolerances values were ascertained to work for a different wave
    # direction. They're also the same as those in the test above.
    assert np.isclose(samples[0],true_value,atol=1e-16,rtol=1e-2)

    
def test_set_seed():
    """Checks the numpy seed setter works."""

    np.random.seed(1)

    random_number_1 = np.random.rand(1)

    point_gen.set_numpy_seed(None)

    random_number_2 = np.random.rand(1)

    assert random_number_1 != random_number_2

    point_gen.set_numpy_seed(1)

    random_number_3 = np.random.rand(1)

    assert random_number_1 == random_number_3


